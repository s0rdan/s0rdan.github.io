---
title: Euler 12
description: Highly divisible triangular number
---

## The Problem [*](https://projecteuler.net/problem=12)


The sequence of triangle numbers is generated by adding the natural numbers. So the \\(7^{th}\\) triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

<center>
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
</center>
Let us list the factors of the first seven triangle numbers:

~~~python
 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
~~~
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?

## The Approach

This problem seems rather straightforward. We must calculate the triangle numbers' prime factors until we find one that has over 500 divisors. The relation between a number's prime factors and its divisors is the following:

> Any number can be written as a combination of its prime factor. For example: \\( 18 = 2 \cdot 3^2\\). The prime factors are 2 and 3. There are 6 divisors: 1, 2, 3, 6, 9, 18. More generally, any number can be written as a product of prime factors: \\( a\_1^l \cdot a\_2^m \cdot a\_3^n \cdot \dots \\) The number of divisors are then \\( (l + 1) \cdot (m + 1) \cdot (n + 1) \dots\\) which makes sense if you think about it.

Another property of triangle numbers that one can see becoming useful is the fact that they can be written with the following form:

\\[ T(n) = \frac{n \cdot (n + 1)}{2} \\]

Thus, instead of factoring one large number, one can more easily factor two smaller numbers of the order of \\( \sqrt{n} \\) in size i.e. \\( n / 2 \\) and \\( n + 1 \\), n even; n and (n + 1) / 2, n odd. The numbers n and n + 1 are relatively primes, sharing only 1 as a common factor. If an integer d were a factor of both n and n + 1, then d would also be a factor of (n + 1) - n. Hence d can only be 1.

Now comes the problem of integer factorisation. A simple approach involves going through a list of primes to find the factors. One can also check if powers of these factors are also factors.

## Prime Number Generator

An efficient snippet I came across on stack overflow is the following. It could be improved by factoring the n and n + 1 factors separately, instead of trying to factorise the triangle numbers first. 

~~~python
def primesfrom2to(n):
    # http://stackoverflow.com/questions/2068372/fastest-way-to-list-all-primes-below-n-in-python/3035188#3035188
    """ Input n>=6, Returns a array of primes, 2 <= p < n """
    sieve = np.ones(n/3 + (n%6==2), dtype=np.bool)
    sieve[0] = False
    for i in xrange(int(n**0.5)/3+1):
        if sieve[i]:
            k=3*i+1|1
            sieve[      ((k*k)/3)      ::2*k] = False
            sieve[(k*k+4*k-2*k*(i&1))/3::2*k] = False
    return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)]
~~~

##An Elegant Solution
This code ran in a 3.4 seconds on my 2.4Ghz MacBook Pro. The triangle numbers are directly factorised and a faster implementation could be obtained by following the method outlined above.

~~~python
# A primeList has been generated
nd = 0 #  The number of divisors
x = 0 #  Tiangular numbers
i = 1
while nd <= 500:
    x = x + i #  These two lines create
    i = i + 1 #  the triangular numbers 
    nd = 2 #  1 and x
    nd_count = 1
    j = 0
    y = x
    while y > 1: #  y is reduced by the factors until it reaches 1
        k = 1
        while x%int(primeList[j])**k == 0: #  this loop checks for powers of the primes being factors
            k = k + 1 #  
        if x%int(primeList[j]) == 0:
            nd_count = nd_count * k #  product of factors' exponents + 1
            y = y/(int(primeList[j])**(k-1)) #  y is divided by the new-found factors
        j = j + 1 #  iterate through list of primes
    if (nd_count > nd):
        nd = nd_count
print x, nd
# 76576500 576
~~~
